<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />
  <title>HTML Form and JSON for single endpoint in FastAPI - Max Scheijen</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../../theme/css/main.css" type="text/css" />
  <link rel="stylesheet" href="../../theme/css/syntax.css" type="text/css" />
  <link rel="icon" type="image/png" sizes="16x16" href="../../theme/images/favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../../theme/images/favicon-32x32.png">
  
  <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Max Scheijen - Flux ATOM" />
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DC0740CRYY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', "G-DC0740CRYY");
  </script>
</head>
<body>
  <main>
        
  <h1>HTML Form and JSON for single endpoint in FastAPI</h1>
  <a href="/" class="by">Oct 05, 2024 - By Max Scheijen</a>
  <div class="meta">
    <!-- <p>Oct 05, 2024</p> -->
    <!-- <p></p> -->
  </div>
  <article>
  <p>A common challenge when building a FastAPI application is handling different content types, like <code>JSON</code> and <code>Form</code> data. Any many cases your API needs to support both formats, especially when dealing with web forms and modern front-end applications that often send json payloads.</p>
<p>This post demonstrates how to build a FastAPI application that handles and validates both JSON and from data inputs on a <strong>single endpoint</strong>.</p>
<h2>The Challenge: Handling Different Content Types</h2>
<p>By default, web browsers use <code>application/x-www-form-urlencoded</code> or <code>multipart/form-data</code> content types when submitting forms. On the other hand, APIs and modern front-ends typically send <code>application/json</code>. Our goal is to handle both efficiently and return appropriate responses.</p>
<p>To achieve this I'll:</p>
<ul>
<li>Use dependency injection in FastAPI to dynamically process the request type (form or json).</li>
<li>Validate the incoming data using Pydantic.</li>
<li>Handle errors gracefully, including invalid content types and validation errors.</li>
</ul>
<h2>Code Breakdown</h2>
<p>Let’s dive into each part of this code to understand how it works.</p>
<h3>Validation</h3>
<p>We define a Pydantic model <code>User</code> to enforce structure and validation on the incoming data. In this case, it expects a single field: <code>name</code>. This model will automatically validate the incoming data whether it comes from a form or a json body.</p>
<p>You can extend this model by adding more fields as needed.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div>

<h3>Request Type</h3>
<p>Below, I use the <code>request_type</code> function to dynamically handle both <code>JSON</code> and <code>Form</code> content types. The <code>Request</code> object is used to inspect the content type of the incoming request:</p>
<ul>
<li>If the content type is <code>application/x-www-form-urlencoded</code>, we treat it as form data and convert it to a dictionary using <code>await request.form()</code>.</li>
<li>If it’s <code>application/json</code>, we parse it into a dictionary using <code>await request.json()</code>.</li>
<li>If the content type is unsupported, we raise a <code>ValueError</code>.</li>
</ul>
<p>Later on the <code>request_type</code> function is injected into the route via FastAPI’s <code>Depends</code> feature.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">Request</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">request_type</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="n">Request</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="c1"># Get content-type (json or form) from request</span>
    <span class="n">content_type</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Content-Type&quot;</span><span class="p">)</span>

    <span class="c1"># Convert form to dict</span>
    <span class="k">if</span> <span class="n">content_type</span> <span class="o">==</span> <span class="s2">&quot;application/x-www-form-urlencoded&quot;</span><span class="p">:</span>
        <span class="n">form_data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">form_data</span><span class="p">)</span>

    <span class="c1"># Convert json to dict</span>
    <span class="k">elif</span> <span class="n">content_type</span> <span class="o">==</span> <span class="s2">&quot;application/json&quot;</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

    <span class="c1"># Handle unsupported content types</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported content type: </span><span class="si">{</span><span class="n">content_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>
</code></pre></div>

<h3>Handle Request in Route</h3>
<p>This is the main route for handling incoming requests. The <code>data</code> returned by the <code>request_type</code> function is validated against the <code>User</code> model. If the validation succeeds, it means that the request body (whether JSON or form) is valid and contains the correct structure.</p>
<p>When the request’s content type is form data (<code>application/x-www-form-urlencoded</code>), we return a simple HTML response. This can of course be extended to return more complex HTML content based on your needs.</p>
<p>For JSON requests, the validated data is returned as the response.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">json</span>

<span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">Depends</span><span class="p">,</span> <span class="n">FastAPI</span>
<span class="kn">from</span> <span class="nn">fastapi.responses</span> <span class="kn">import</span> <span class="n">JSONResponse</span><span class="p">,</span> <span class="n">HTMLResponse</span>


<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">root</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="n">Request</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">Depends</span><span class="p">(</span><span class="n">request_type</span><span class="p">)):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Validate data using pydantic model</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># content-type is form, return HTML response</span>
        <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Content-Type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;application/x-www-form-urlencoded&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">HTMLResponse</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&lt;p&gt;Hello, </span><span class="si">{</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">!&lt;/p&gt;&quot;</span><span class="p">)</span>

        <span class="c1"># content-type not form return dict/json</span>
        <span class="k">return</span> <span class="n">user</span>

    <span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Exception handling when form or json data is invalid</span>
        <span class="k">return</span> <span class="n">JSONResponse</span><span class="p">(</span>
            <span class="n">content</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">json</span><span class="p">()),</span>
            <span class="n">status_code</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Handle unsupported content type</span>
        <span class="k">return</span> <span class="n">JSONResponse</span><span class="p">(</span>
            <span class="n">content</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)},</span>
            <span class="n">status_code</span><span class="o">=</span><span class="mi">415</span><span class="p">,</span>  <span class="c1"># Unsupported Media Type</span>
        <span class="p">)</span>
</code></pre></div>

<p>If the data doesn’t meet the Pydantic model’s validation rules, a <code>ValidationError</code> is raised, and a <code>400 Bad Request</code> error with the detailed validation errors is returned as a JSON response.</p>
<p>When the content type is unsupported, we catch the <code>ValueError</code> and return a <code>415 Unsupported Media Type</code> error with a descriptive message.</p>
<h2>Testing</h2>
<p>We can now make a request using a json body or a form to the same endpoint</p>
<div class="codehilite"><pre><span></span><code>curl<span class="w"> </span>--location<span class="w"> </span><span class="s1">&#39;http://127.0.0.1:8000 &#39;</span><span class="w"> </span><span class="se">\</span>
--header<span class="w"> </span><span class="s1">&#39;Content-Type: application/json&#39;</span><span class="w"> </span><span class="se">\</span>
--data<span class="w"> </span><span class="s1">&#39;{</span>
<span class="s1">    &quot;name&quot;: &quot;John Doe&quot;</span>
<span class="s1">}&#39;</span>
</code></pre></div>

<p>This will return the following json response.</p>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;John Doe&quot;</span>
<span class="p">}</span>
</code></pre></div>

<p>We can also make a request using a form</p>
<div class="codehilite"><pre><span></span><code>curl<span class="w"> </span>--location<span class="w"> </span><span class="s1">&#39;http://127.0.0.1:8000 &#39;</span><span class="w"> </span><span class="se">\</span>
--header<span class="w"> </span><span class="s1">&#39;Content-Type: application/x-www-form-urlencoded&#39;</span><span class="w"> </span><span class="se">\</span>
--data-urlencode<span class="w"> </span><span class="s1">&#39;name=John Doe&#39;</span>
</code></pre></div>

<p>This results in a HTML string</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Hello, John Doe!<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
</code></pre></div>

<p>When incorrect fields are specified this will result in a nice pydantic validation error response.</p>
<div class="codehilite"><pre><span></span><code>curl<span class="w"> </span>--location<span class="w"> </span><span class="s1">&#39;http://127.0.0.1:8000 &#39;</span><span class="w"> </span><span class="se">\</span>
--header<span class="w"> </span><span class="s1">&#39;Content-Type: application/x-www-form-urlencoded&#39;</span><span class="w"> </span><span class="se">\</span>
--data-urlencode<span class="w"> </span><span class="s1">&#39;user=John Doe&#39;</span>
</code></pre></div>

<p>The incorrect field <code>user</code> is used this will result in the following response</p>
<div class="codehilite"><pre><span></span><code><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;missing&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;loc&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="s2">&quot;name&quot;</span>
<span class="w">        </span><span class="p">],</span>
<span class="w">        </span><span class="nt">&quot;msg&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Field required&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;input&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;user&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;John Doe&quot;</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;url&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;https://errors.pydantic.dev/2.6/v/missing&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">]</span>
</code></pre></div>

<h2>Benefits</h2>
<p>This pattern allows for seamlessly processing both form and JSON data, making our API more flexible.</p>
<p>It also leverages Pydantic’s integration with FastAPI ensures that incoming json or form data is validated automatically based on the schema we define.</p>
<p>Unsupported content types and validation errors are handled gracefully, providing clear error messages to the client.</p>
<p>By using dependency injection (<code>Depends</code>), the code remains modular. The logic for handling and converting request data is abstracted away, making the route handler simpler and more readable.</p>
  </article>
  </main>
</body>
</html>