<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />
  <title>refire - A lightweight retrier - Max Scheijen</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../../theme/css/main.css" type="text/css" />
  <link rel="stylesheet" href="../../theme/css/syntax.css" type="text/css" />
  <link rel="icon" type="image/x-icon" href="../../theme/images/favicon/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="../../theme/images/favicon/favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../../theme/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="192x192" href="../../theme/images/favicon/android-chrome-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="../../theme/images/favicon/android-chrome-512x512.png">
  <link rel="apple-touch-icon" type="image/png" sizes="512x512" href="../../theme/images/favicon/apple-touch-icon.png">
  
  <link href="../../feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Max Scheijen - Flux ATOM" />
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DC0740CRYY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', "G-DC0740CRYY");
  </script>
</head>
<body>
  <main>
        
  <h1>refire - A lightweight retrier</h1>
  <a href="/" class="by">Sep 15, 2025 - By Max Scheijen</a>
  <div class="meta">
    <!-- <p>Sep 15, 2025</p> -->
    <!-- <p></p> -->
  </div>
  <article>
  <p>Failures happen. APIs timeout, flaky network calls fail, and sometimes random conditions causes your code to misbehave. Instead of writing repetitive retry logic in every function, wouldn’t it be better to have a clean, reusable decorator that takes care of retries for you? </p>
<p>That’s exactly why I built <a href="https://github.com/maxscheijen/refire">refire</a>, a simple (no dependencies) yet powerful Python package that helps you retry functions on failure with configurable retry policies, exponential backoff, and jitter.</p>
<h2>Why refire?</h2>
<p>When dealing with unreliable resources like APIs, databases, or external services, retrying operations is often the simplest way to build resilience. But manually implementing retries quickly leads to messy, repetitive code.</p>
<p>refire makes retrying clean and declarative:</p>
<ul>
<li>Retry on specific exceptions</li>
<li>Control number of attempts (or retry indefinitely)</li>
<li>Apply exponential backoff</li>
<li>Add jitter to prevent retry storms</li>
<li>Cap retries with a maximum delay</li>
<li>Log retry attempts automatically</li>
</ul>
<h2>Installation</h2>
<div class="codehilite"><pre><span></span><code>pip<span class="w"> </span>install<span class="w"> </span>refire
<span class="c1"># or </span>
uv<span class="w"> </span>add<span class="w"> </span>refire
</code></pre></div>

<p>Requires Python <strong>3.10+</strong>.</p>
<h2>Quick Start</h2>
<p>Here’s a simple example of using <code>refire</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">refire</span> <span class="kn">import</span> <span class="n">refire</span>


<span class="nd">@refire</span><span class="p">(</span><span class="n">tries</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">flaky_function</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.7</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unlucky!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;Success!&quot;</span>


<span class="nb">print</span><span class="p">(</span><span class="n">flaky_function</span><span class="p">())</span>
</code></pre></div>

<p>In this example:</p>
<ul>
<li>The function will retry <strong>up to 5 times</strong>.</li>
<li>The first retry waits <strong>1 second</strong>, then doubles each time (backoff=2).</li>
<li>A random jitter between <strong>0 and 1 second</strong> is added to the delay.</li>
<li>If all retries fail, the last exception is re-raised.</li>
</ul>
<p>So, you might see log output like:</p>
<div class="codehilite"><pre><span></span><code>WARNING:root:Caught ValueError: Unlucky!. Retrying in 1.00s (remaining=4)
WARNING:root:Caught ValueError: Unlucky!. Retrying in 2.34s (remaining=3)
WARNING:root:Caught ValueError: Unlucky!. Retrying in 4.89s (remaining=2)
...
</code></pre></div>

<h2>Customizing Retry Policies</h2>
<p>You have full control over retry behavior:</p>
<p><strong>Retry on specific exceptions:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nd">@refire</span><span class="p">(</span><span class="n">exceptions</span><span class="o">=</span><span class="p">(</span><span class="ne">ConnectionError</span><span class="p">,</span> <span class="ne">TimeoutError</span><span class="p">),</span> <span class="n">tries</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fetch_data</span><span class="p">():</span>
    <span class="o">...</span>
</code></pre></div>

<p><strong>Infinite retries until success:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nd">@refire</span><span class="p">(</span><span class="n">tries</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">always_retry</span><span class="p">():</span>
    <span class="o">...</span>
</code></pre></div>

<p><strong>Cap the maximum delay</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nd">@refire</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">backoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_delay</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">capped_backoff</span><span class="p">():</span>
    <span class="o">...</span>
</code></pre></div>

<p><strong>Integrate with your own logger:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;myapp&quot;</span><span class="p">)</span>

<span class="nd">@refire</span><span class="p">(</span><span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">log_level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">with_logging</span><span class="p">():</span>
    <span class="o">...</span>
</code></pre></div>

<h2>Retrying on Custom Exceptions</h2>
<p>You can also define your own exceptions and configure refire to retry only when they occur:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">TemporaryAPIError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the API fails temporarily.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">CriticalAPIError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raised when the API fails permanently (don’t retry).&quot;&quot;&quot;</span>


<span class="nd">@refire</span><span class="p">(</span><span class="n">exceptions</span><span class="o">=</span><span class="n">TemporaryAPIError</span><span class="p">,</span> <span class="n">tries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fetch_from_api</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.8</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">TemporaryAPIError</span><span class="p">(</span><span class="s2">&quot;Temporary failure, please retry.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.9</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">CriticalAPIError</span><span class="p">(</span><span class="s2">&quot;Critical failure, do not retry!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;Fetched data!&quot;</span>
</code></pre></div>

<ul>
<li>If a <code>TemporaryAPIError</code> is raised, the function will retry up to <strong>3 times</strong> with a <strong>2s delay</strong>.</li>
<li>If a <code>CriticalAPIError</code> is raised, it will <strong>not retry</strong> and immediately propagate the exception.</li>
</ul>
<p>This makes refire flexible: you can fine-tune retry behavior depending on whether an error is transient or permanent.</p>
<h2>When to Use (and When Not To)</h2>
<p>Use refire when:</p>
<ul>
<li>Making unreliable API calls</li>
<li>Accessing flaky external services</li>
<li>Running operations that often succeed on retry</li>
</ul>
<p>Don’t use refire when:</p>
<ul>
<li>Failures are deterministic and retries won’t help</li>
<li>Retrying could cause unintended side effects (e.g., duplicate financial transactions)</li>
</ul>
<h2>Roadmap</h2>
<p>The current version (0.1.0) is lightweight and focused. Future plans include:</p>
<ul>
<li>Support for async functions</li>
<li>Custom retry policies (e.g., Fibonacci backoff)</li>
<li>Context-aware retries (timeouts, cancellation)</li>
</ul>
<h2>Try It Out</h2>
<p>The package is open-source under the <strong>Apache-2.0 license</strong> and available here:</p>
<p>GitHub – <a href="https://github.com/maxscheijen/refire">maxscheijen/refire</a></p>
<p>If you want a <strong>clean, reusable way to add resilience</strong> to your Python code, give refire a try — and let me know what you think!</p>
  </article>
  </main>
</body>
</html>